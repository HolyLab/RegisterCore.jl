<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>An overview of the Registration framework · RegisterCore</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>RegisterCore</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>An overview of the Registration framework</a><ul class="internal"><li><a class="toctext" href="#Mismatch-1">Mismatch</a></li><li><a class="toctext" href="#CenterIndexedArray-1">CenterIndexedArray</a></li><li><a class="toctext" href="#NumDenom-1">NumDenom</a></li><li><a class="toctext" href="#Apertured-mismatch:-computing-mismatch-in-blocks-1">Apertured mismatch: computing mismatch in blocks</a></li><li><a class="toctext" href="#NaN-values-1">NaN values</a></li></ul></li><li><a class="toctext" href="api/">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>An overview of the Registration framework</a></li></ul><a class="edit-page" href="https://github.com/HolyLab/RegisterCore.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>An overview of the Registration framework</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="An-overview-of-the-Registration-framework-1" href="#An-overview-of-the-Registration-framework-1">An overview of the Registration framework</a></h1><p>This is a bit of an overview of the main concepts that underlie the overall registration framework. <code>RegisterCore</code> itself only contains low-level utilities for working with &quot;mismatch data,&quot; as well as a few miscellaneous utilities.</p><h2><a class="nav-anchor" id="Mismatch-1" href="#Mismatch-1">Mismatch</a></h2><p><em>Mismatch</em> refers to the mean-square pixelwise difference between two images of the same size.  The mismatch is computed from two images, called <code>fixed</code> and <code>moving</code>. Suppose that <code>fixed</code> and <code>moving</code> are grayscale two-dimensional images of size <code>m</code>-by-<code>n</code>. Computing the mismatch <code>D</code> for a zero-pixel shift would result in a single number; computing for shift by one pixel along the first coordinate (a shift of <code>(1,0)</code>) would result in a different number. Using a <code>maxshift</code> of <code>(3,4)</code>, we could store the mismatch for all possible shifts in an array <code>D</code> of size <code>(7,9)</code>.</p><p>The <a href="https://github.com/HolyLab/RegisterMismatch.jl">RegisterMismatch</a> package contains a function</p><pre><code class="language-none">D = mismatch(fixed, moving, maxshift; normalization=:intensity)</code></pre><p>It computes the result of all translations by an integer number of pixels within a range <code>-maxshift[i]:maxshift[i]</code> along coordinate <code>i</code>.</p><p>Let&#39;s do a simple example. Suppose your image data look like this:</p><pre><code class="language-none">julia&gt; img = [0 0 0 0 0;
              0 0 1 0 0;
              0 2 1 1 0;
              0 0 3 0 0;
              0 0 0 0 0]
5×5 Array{Int64,2}:
 0  0  0  0  0
 0  0  1  0  0
 0  2  1  1  0
 0  0  3  0  0
 0  0  0  0  0</code></pre><p>Let&#39;s compute the mismatch of this image as we shift it relative to itself. Here we&#39;ll do this for shifts from -2 to 2 along each coordinate. For ease of display let&#39;s convert the output to integer format, though in practical work there would be no particular reason to do so:</p><pre><code class="language-none">julia&gt; using RegisterCore, RegisterMismatch

julia&gt; D = round.(NumDenom{Int}, mismatch(img, img, (2,2)))
5×5 CenterIndexedArrays.CenterIndexedArray{NumDenom{Int64},2,Array{NumDenom{Int64},2}} with indices SymRange(2)×SymRange(2):
 NumDenom(17,17)  NumDenom(22,22)  NumDenom(16,22)  NumDenom(22,22)  NumDenom(17,17)
 NumDenom(27,27)  NumDenom(18,32)  NumDenom(24,32)  NumDenom(22,32)  NumDenom(27,27)
 NumDenom(23,27)  NumDenom(26,32)  NumDenom(0,32)   NumDenom(26,32)  NumDenom(23,27)
 NumDenom(27,27)  NumDenom(22,32)  NumDenom(24,32)  NumDenom(18,32)  NumDenom(27,27)
 NumDenom(17,17)  NumDenom(22,22)  NumDenom(16,22)  NumDenom(22,22)  NumDenom(17,17)</code></pre><p>This looks a little complicated, so let&#39;s walk through the pieces.</p><h2><a class="nav-anchor" id="CenterIndexedArray-1" href="#CenterIndexedArray-1">CenterIndexedArray</a></h2><p>Shift data are stored in a type called a <code>CenterIndexedArray</code>, in which indexing is performed relative to the center.  Consequently, <code>D[0,0]</code> (the center point) would correspond to the mismatch between <code>fixed</code> and <code>moving</code> without any translational shift. <code>D[1,0]</code>, displaced from the center by <code>(1,0)</code>, represents the mismatch for a single-pixel shift of <code>moving</code> along the first coordinate. Likewise, <code>D[-1,0]</code> corresponds to an identical shift in the opposite direction.</p><h2><a class="nav-anchor" id="NumDenom-1" href="#NumDenom-1">NumDenom</a></h2><p>Mismatch computations actually return two numbers, conventionaly called <code>num</code> and <code>denom</code> packed into a type called <code>NumDenom</code>. <code>num</code> represents the &quot;numerator&quot; of the mismatch, and always holds the sum-of-squared-differences.  In our example above, you can check</p><pre><code class="language-none">julia&gt; D[1,0].num
24

julia&gt; sum((img[1:end-1,:] - img[2:end,:]).^2)
24</code></pre><p>One key thing to note is that this sum-of-squared-differences includes  <em>only overlapping pixels</em>. In the example above, <code>D[2,0]</code> is <code>NumDenom(16, 22)</code>, and the 16 comes from</p><pre><code class="language-none">julia&gt; sum((img[1:end-2,:] - img[3:end,:]).^2)
16</code></pre><p>If you look at how we defined <code>img</code>, the pixel with value <code>3</code> is included in <code>img[3:end,:]</code> but omitted from <code>img[1:end-2,:]</code>. If all you did was pay attention to the value of <code>D[2,0].num</code>, you might conclude that a shift of <code>2,0</code> is better than a shift of <code>1,0</code>, even though the latter is closer to the true ideal of <code>0,0</code>.</p><p><code>denom</code> can be used for normalizing these differences, and can follow one of two conventions. <code>:pixel</code> normalization returns the number of valid pixels in the overlap region, including the effects of any shift; for a shift of <code>(0,0)</code> that would be <code>m*n</code>, but for a shift of <code>(1,0)</code> it would be <code>(m-1)*n</code>, because we clip one row of each image.  <code>:intensity</code> normalization computes the sum-of-square intensities within the overlap region. We can check that directly for our example above:</p><pre><code class="language-julia">julia&gt; D[1,0].denom
32

julia&gt; sum(img[1:end-1,:].^2 + img[2:end,:].^2)
32</code></pre><p><code>mismatch</code> uses a default normalization of <code>:intensity</code>, because that makes the overall ratio <code>num/denom</code> a dimensionless quantity that does not depend on the brightness of your illumination or the units used to report intensities.</p><p>While one might initially imagine returning the ratio <code>num/denom</code> directly–-thus computing the <em>fractional</em> square difference–-there are several reasons to return <code>num</code> and <code>denom</code> separately:</p><ul><li>If the shift is so large that there are no pixels of overlap between <code>fixed</code> and <code>moving</code>, both <code>num</code> and <code>denom</code> should be zero. However, because <code>num</code> and <code>denom</code> are generally computed by Fourier methods, there will be roundoff error (the reason we called <code>round</code> in the example above), and therefore their ratio can oscillate crazily. Returning them separately allows you to control the threshold for what is considered &quot;signal&quot; or &quot;noise&quot; (see <code>truncatenoise!</code> and related functions below). Indeed, by appropriate choice of threshold you can require a minimum finite overlap, for example in terms of numbers of pixels (for <code>:pixel</code> normalization) or amount of image intensity (for <code>:intensity</code> normalization). A particularly robust strategy is to use a threshold that is some fixed fraction of the total sum-squared power, e.g., with <code>:intensity</code> normalization, <code>0.25*D[0,0].denom</code> would insist on shifts that achieve overap of at least 25% of the total power in the <code>fixed</code> and <code>moving</code> images.</li><li>For sub-pixel registration, one might imagine <em>interpolating</em> the mismatch values to positions between grid points.  If we worked directly with the ratio <code>num/denom</code>, shifts where these two values are pure noise (due to little overlapping power) would contaminate adjacent shifts that are not noise.  By separately interpolating <code>num</code> and <code>denom</code> and <em>then</em> forming their ratio, we provide the opportunity for well-determined mismatch values to overwhelm the noise from shifts whose mismatch ratios are meaningless (i.e., <code>(bignum + noisenum)/(bigdenom + noisedenom)</code> is robust and nearly independent of the tiny noise contribution, whereas <code>bignum/bigdenom + noisenum/noisedenom</code> is likely to be meaningless).</li><li>Mathematically, &quot;apertured&quot; (block) computation involves sums of <code>num</code> and <code>denom</code> arrays separately (see below).</li></ul><p>To support interpolation and other operations, it is most efficient to give <code>NumDenom</code> objects an algebra like a 2-vector (see <a href="api/#RegisterCore.NumDenom"><code>NumDenom</code></a>). This <em>badly</em> violates any pretense that <code>nd</code> is equivalent to <code>nd.num/nd.denom</code>. Consequently, the absence of a <code>convert(Float64, nd)</code> operation (which often gets called &quot;automatically&quot;) is deliberate; use <a href="api/#RegisterCore.ratio"><code>ratio</code></a> or manual operations if you do want to &quot;instantiate&quot; them as a ratio.</p><h2><a class="nav-anchor" id="Apertured-mismatch:-computing-mismatch-in-blocks-1" href="#Apertured-mismatch:-computing-mismatch-in-blocks-1">Apertured mismatch: computing mismatch in blocks</a></h2><p>Mismatch can be computed as a whole, or over <em>apertures</em>. The basic concept behind apertures is simple: given that an image may deform differently in different portions of space, restrict the mean-square-error computation to a local group of pixels.</p><p>Currently, apertures are arranged in a grid, although this may change in the future.  Conceptually, if you want a (2,2) grid of blocks, you break the <code>fixed</code> and <code>moving</code> images up into quadrants and compute the mismatch separately for each quadrant. The actual implementation is a bit more complex, but also a bit more useful:</p><ul><li>Apertures are not &quot;clipped&quot; before computing the mismatch as a function of shift; instead, clipping at boundaries effectively happens after shifting. This allows one to use all the information available in both images.</li><li>One might naively assume that, when using a <code>gridsize</code> of (3,3), you might split the image up like this:</li></ul><p><img src="gridinner.png" alt="gridinner"/></p><p>Instead, this suite of packages uses apertures like this:</p><p><img src="gridcenter.png" alt="gridcentered"/></p><p>In each aperture, the data used for comparison are symmetric around the block center. As a consequence, the <code>[1,1]</code> aperture has 3/4 of its data (upper-left, upper-right, and lower-left quadrants) missing. By contrast, the <code>[2,2]</code> aperture does not have any missing data, and by default the <code>[2,2]</code> aperture includes <code>9/16 = (3/4)^2</code> of the pixels in the image (with the boundary at the halfway point between block centers). The motivation for this convention is that it reduces the need to <em>extrapolate</em> shifts, because the aperture centers span the entire fixed image.</p><p>When the apertures are arranged in a grid pattern, the mismatch arrays for each aperture can be stored in an array-of-arrays.  The &quot;inner&quot; arrays have type <code>CenterIndexedArray{NumDenom{T}}</code> and are indexed by shifts (of either sign).  The &quot;outer&quot; array is indexed in conventional Julia style (starting at 1), where the index represents the grid block.</p><p>A deformation grid is represented as one shift for each aperture. To support sub-pixel registration, the mismatch data are interpolated.</p><p>If you break the image up into blocks, each with its own mismatch array <code>Ds[I]</code>, then the total sum of squared differences for a shift of <code>(0, 0)</code> is</p><pre><code class="language-none">sum(D[0,0].num for D in Ds)</code></pre><p>and the total normalization is</p><pre><code class="language-none">sum(D[0,0].denom for D in Ds)</code></pre><p>Consequently the <code>num/denom</code> ratio should be computed <em>after</em> summing all the individual contributions to the numerator and denominator.</p><h2><a class="nav-anchor" id="NaN-values-1" href="#NaN-values-1">NaN values</a></h2><p>Any pixels with <code>NaN</code> values are omitted from mismatch computation, for both the numerator and denominator. (Most of this framework was written long before Julia had developed <code>missing</code>.) This is treated quite differently from filling <code>NaN</code>s with zero; instead, it&#39;s as if those pixels simply don&#39;t exist. This provides several nice features:</p><ul><li>You can register a smaller image to a larger one by padding the smaller image with NaN. The registration will not be affected by the fact that there&#39;s an &quot;edge&quot; at the padding location.</li><li>You can re-register a warped moving image to the fixed image (hoping to further improve the registration), and not worry about the fact that the edges of the warped image likely have NaNs.</li><li>You can mark &quot;bad pixels&quot; produced by your camera.</li></ul><footer><hr/><a class="next" href="api/"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
